---
title: "week3"
author: "Lisa Wahlen"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(readr) # to import tabular data (e.g. csv)
library(dplyr) # to manipulate (tabular) data
library(ggplot2) # to visualize data
library(sf) # to handle spatial vector data
library(terra) # To handle raster data
library(lubridate) # To handle dates and times
library(RColorBrewer)

mycolors4 <- brewer.pal(4, "BrBG")
```

You've read Laube and Purves (2011) about segmenting trajectories. In the paper, the authors define "static" fixes as "those whose average Euclidean distance to other fixes inside a temporal window v is less than some threshold d", as illustrated in the following figure:

![](images/laube_2011-01.png)

a.  Specify a temporal windows v for in which to measure Euclidean distances

b.  Measure the distance from every point to every other point within this temporal window (v)

c.  Remove \"static points\": These are points where the average distance is less than a given threshold. This segments the trajectory into subtrajectories

d.  Now remove short subtrajectories: These are trajectories with a short duration (whereas \"short\" is tbd)

We will **demonstrate** implementing this method on the wild boar \"Sabi\", restricting ourselves to a couple of tracking days. Your task will be to understand this implementation and apply it on Caro, with a different sampling interval.

#### **Step a): Specify a temporal window** *v*

In the above dataset, the sampling interval is 15 minutes. If we take a temporal window of 60 minutes, that would mean including 4 fixes. We need to calculate the following Euclidean distances (pos representing single location):

1.  `pos[n-2]` to `pos[n]`

2.  `pos[n-1]` to `pos[n]`

3.  `pos[n]` to `pos[n+1]`

4.  `pos[n]` to `pos[n+2]`

```{r}
caro <- read_csv("data/caro60.csv")
```

#### **Step b): Measure the distance from every point to every other point within this temporal window** *v*

Just like last week, we use the formula for calculating the Euclidean distance in in combination with `lead()` and `lag()`. For example, to create the necessary offset of n-2, we use `lag(x, 2)`. For each offset, we create one individual column.

```{r}
caro <- caro |>
    mutate(
        nMinus2 = sqrt((lag(E, 2) - E)^2 + (lag(N, 2) - N)^2), # distance to pos -30 minutes
        nMinus1 = sqrt((lag(E, 1) - E)^2 + (lag(N, 1) - N)^2), # distance to pos -15 minutes
        nPlus1  = sqrt((E - lead(E, 1))^2 + (N - lead(N, 1))^2), # distance to pos +15 mintues
        nPlus2  = sqrt((E - lead(E, 2))^2 + (N - lead(N, 2))^2) # distance to pos +30 minutes
    )
```

Now we want to calculate the mean distance of `nMinus2`, `nMinus1`, `nPlus1`, `nPlus2` for each row. Since we want the mean value *per Row*, we have to explicitly specify this before `mutate()` with the function `rowwise()`. To remove this rowwise-grouping, we end the operation with `ungroup()`.

Note that for the first two positions, we cannot calculate a `stepMean` since there is no Position `n-2` for these positions. This is also true for the last to positions (lacking a position `n+2`).

```{r}
caro <- caro |>
    rowwise() |>
    mutate(
        stepMean = mean(c(nMinus2, nMinus1, nPlus1, nPlus2))
    ) |>
    ungroup()

caro
```

#### **Step c): Remove \"static points\"**

We can now determine if an animal is moving or not by specifying a threshold distance on `stepMean`. In our example, we use the mean value as a threshold: Positions with distances below this value are considered static.

```{r}
caro <- caro |>
    ungroup() |>
    mutate(static = stepMean < mean(stepMean, na.rm = TRUE))

caro_filter <- caro |>
    filter(!static)

caro_filter |>
    ggplot(aes(E, N)) +
    geom_path() +
    geom_point() +
    coord_fixed() +
    theme(legend.position = "bottom")
```

### **Task 1: Segmentation**

If you haven\'t already done so open the RStudio Project [you have prepared](https://computationalmovementanalysis.github.io/FS23/Week3/W3_3_preparation.html) for this week.

With the skills from the input above you can now implement the segmentation algorithm described in Laube and Purves ([2011](https://computationalmovementanalysis.github.io/FS23/90_references.html#ref-laube2011)) on the dataset [caro60.csv](https://moodle.zhaw.ch/pluginfile.php/1168373/mod_folder/content/0/caro60.csv?forcedownload=1). Download this dataset (right click \> save target as...) and import it as a simple `data.frame` or `tibble` (you don\'t need an `sf`-object for today\'s task).

The sampling interval for this dataset is 1 minute. Use a temporal window v of 6 minutes, i.e. a window size of 6 positions (`n±3`).

Once you have completed the task, commit your changes with a meaningful commit message and test your connection to Github by pushing your changes to your remote repository.

```{r}
caro <- read_csv("data/caro60.csv")
```

```{r}
caro <- caro |>
    mutate(
      nMinus3 = sqrt((lag(E, 3) - E)^2 + (lag(N, 3) - N)^2), # distance to pos -3 minutes
        nMinus2 = sqrt((lag(E, 2) - E)^2 + (lag(N, 2) - N)^2), # distance to pos -2 minutes
        nMinus1 = sqrt((lag(E, 1) - E)^2 + (lag(N, 1) - N)^2), # distance to pos -1 minutes
        nPlus1  = sqrt((E - lead(E, 1))^2 + (N - lead(N, 1))^2), # distance to pos +1 mintues
        nPlus2  = sqrt((E - lead(E, 2))^2 + (N - lead(N, 2))^2), # distance to pos +2 minutes
      nPlus3 = sqrt((E - lead(E, 3))^2 + (N - lead(N, 3))^2), # distance to pos +2 minutes
    )
```

```{r}
caro <- caro |>
    rowwise() |>
    mutate(
        stepMean = mean(c(nMinus3, nMinus2, nMinus1, nPlus1, nPlus2, nPlus3))
    ) |>
    ungroup()

caro
```

### **Task 2: Specify and apply threshold *d***

After calculating the Euclidean distances to positions within the temporal window *v* in task 1, you can explore these values (we stored them in the column `stepMean`) using summary statistics (histograms, boxplot, `summary()`): This way we can define a reasonable threshold value to differentiate between *stops* and *moves*. There is no \"correct\" way of doing this, specifying a threshold always depends on data as well as the question that needs to be answered. In this exercise, use the mean of all `stepMean` values.

Store the new information (boolean to differentiate between stops (`TRUE`) and moves (`FALSE`)) in a new column named `static`.

Commit your changes with a meaningful commit message.

```{r}
ggplot(caro, aes(stepMean)) +
  geom_histogram() +
  scale_x_log10()

summary(caro$stepMean)

ggplot(caro, aes(stepMean)) +
  geom_boxplot()
```
